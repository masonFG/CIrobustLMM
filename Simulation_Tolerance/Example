# ---------------------------------------------------------------------
# Author: Fabio Mason
# Date: August, 2020
# R version: 3.6.0
#  R code for analyses presented in

#Mason, F., Cantoni, E., & Ghisletta, P. (submitted). Robust estimation and confidence intervals in linear mixed models.

#This script contains the code to reproduce the sleepstudy example and can be adapted to your own balanced dataset.
# ---------------------------------------------------------------------

###############
# preliminary setup

# 1) Set working directory (select the folder "CIfunctions")
#setwd("..../CIfunctions")

# 2) Load the packages
library(MASS) # version 7.3-51.1
library(robustvarComp) # version 0.1-2
library(robustlmm) # version 2.3
library(heavy) # version 0.38.19
library(lme4) # version 1.1-20
library(lmerTest) # version 3.1-2
library(doParallel) # version 1.0.14
library(stringr)  # version 1.4.0
source("confintLMMFast.R") # function to produce confidence intervals
source("TestFixefFAST.R") # function get p_value based on bootstrap

# 3) Import balanced dataset
#baobab
options(echo=TRUE) 
i <- commandArgs(trailingOnly = TRUE)
rseed=as.numeric(i)
print(rseed)

NTot=180 #nb de sujet Total
#ECHANTILLON 0
n_suj=NTot/2 #nb de sujet
n_mes=5 #nb de mesure max par sujet
set.seed(rseed)
temps<-as.numeric(rep(c(0:(n_mes-1)),n_suj))
id<-sort(as.numeric(rep(1:n_suj,n_mes)))
n_obs = n_suj*n_mes #nb de lignes
extp=0 # pourcentage de valeurs extremes rÃ©sidus
norp=1-extp #pourcentage de valeurs non extremes residus
extRANI=0 #pourcentage de valeurs extremes ranef intercept
norpRANI=1-extRANI #pourcentage de valeurs non extremes ranef intercept
extRANP=0 #pourcentage de valeurs extremes ranef pente
norpRANP=1-extRANP #pourcentage de valeurs non extremes ranef pente
al = 2 #nb d'effet aleatoire par sujet
varRES_n = 0.1 #variance erreurs normale
varRES_e = 0.001 #variance erreurs extremes 
moyRES_e = -4*sqrt(varRES_n) #moyenne des erreurs etremes
matran_n = matrix(c(0.05,0.01,0.01,0.02),2,2) #matrice variance covariance normale
matran_e = matrix(c(0.0005,0.0001,0.0001,0.0002),2,2) #matrice variance covariance extreme
moyran_Ie = c(-4*sqrt(0.05),0) #vecteur moyennes des random intercept
moyran_Pe = c(0,-4*sqrt(0.02)) #vecteur moyennes des random pente
b0 = 1.4 # betaintercept
bG = -0.05 #beta groupe
bT = 0.04 #beta temps
bGxT = 0.15 #beta interaction groupe fois temps

#BDD
pourcentN=min(norpRANI,norpRANP) #pourcentage d'individu non contamines






set.seed(rseed)
reg<-mvrnorm(n=round(norp*n_obs),mu=0,Sigma=varRES_n)
indexRES<-rep(0,length(reg))
res<-data.frame(cbind(reg,indexRES))
colnames(res)<-c("r","indexRES")

if (extp>0){
  set.seed(rseed*1000)
  ext<-mvrnorm(n=round(extp*n_obs),mu=moyRES_e,Sigma=varRES_e)  #residus extremes, normale translate
  indexRES<-rep(1,length(ext))
  ext<-data.frame(cbind(ext,indexRES))
  colnames(ext)<-c("r","indexRES")
  r_inter<-rbind(res,ext)
  
  set.seed(rseed*2000)
  indexRES<-sample(c(1:n_obs),n_obs,replace=F)
  resi<-NULL
  R<-NULL
  for (i in indexRES){
    res<-r_inter[i,] 
    R<-rbind(R,res)
  }
}else{
  R<-cbind(res,sort(rep(c(1:n_suj),n_mes)))
  colnames(R)<-c("r","indexRES","id")
}



##### EFFETS ALEATOIRES #####


#AVEC CORRELATION ENTRE INTERCEPT ET PENTE
#normale
set.seed(rseed+1000)
u_n<-as.data.frame(mvrnorm(round(pourcentN*n_suj),mu=c(0,0),Sigma=matran_n))
u_n$indexI<-0
u_n$indexP<-0

if(extRANI+extRANP==0){
  U<-cbind(u_n,c(1:dim(u_n)[1]))
  colnames(U)<-c("u0","u1","indexRANI","indexRANP","id") 
}else{
  if(extRANI>0){
    #extremeI
    set.seed(rseed+2000)
    u_Ie<-as.data.frame(mvrnorm(round(extRANI*n_suj),mu=moyran_Ie,Sigma=matran_e))
    u_Ie$indexI<-1
    u_Ie$indexP<-0
    u_inter<-data.frame(rbind(u_n,u_Ie))
    
    set.seed(rseed+3000)
    indexRAN<-sample(c(1:n_suj),n_suj,replace=F)
    UU<-NULL
    U<-NULL
    for (i in indexRAN){
      UU<-u_inter[i,] 
      U<-rbind(UU,U)
    }
    U<-cbind(U,c(1:dim(U)[1]))
    colnames(U)<-c("u0","u1","indexRANI","indexRANP","id") 
  }else{
    #extremeP
    set.seed(rseed+2000)
    u_Pe<-as.data.frame(mvrnorm(round(extRANP*n_suj),mu=moyran_Pe,Sigma=matran_e))
    u_Pe$indexI<-0
    u_Pe$indexP<-1
    u_inter<-data.frame(rbind(u_n,u_Pe))
    
    set.seed(rseed+3000)
    indexRAN<-sample(c(1:n_suj),n_suj,replace=F)
    UU<-NULL
    U<-NULL
    for (i in indexRAN){
      UU<-u_inter[i,] 
      U<-rbind(UU,U)
    }
    U<-cbind(U,c(1:dim(U)[1]))
    colnames(U)<-c("u0","u1","indexRANI","indexRANP","id")
  }
}

bdd<-cbind(id,temps)
bdd<-merge(bdd,U)
bdd<-cbind(bdd,R)
bdd0<-bdd[,-9]
bdd0$group <- 0
row.names(bdd0)<-c(1:(n_mes*n_suj))






#ECHANTILLON 1
n_suj=NTot/2 #nb de sujet
n_mes=5 #nb de mesure max par sujet
set.seed(rseed)
temps<-as.numeric(rep(c(0:(n_mes-1)),n_suj))
id<-sort(as.numeric(rep((n_suj+1):(n_suj*2),n_mes)))
n_obs = n_suj*n_mes #nb de lignes
extp=0 # pourcentage de valeurs extremes rÃ©sidus
norp=1-extp #pourcentage de valeurs non extremes residus
extRANI=0 #pourcentage de valeurs extremes ranef intercept
norpRANI=1-extRANI #pourcentage de valeurs non extremes ranef intercept
extRANP=0 #pourcentage de valeurs extremes ranef pente
norpRANP=1-extRANP #pourcentage de valeurs non extremes ranef pente
al = 2 #nb d'effet aleatoire par sujet
varRES_n = 0.1#variance erreurs normale
varRES_e = 0.001#variance erreurs extremes 
moyRES_e = -4*sqrt(varRES_n)#moyenne des erreurs etremes
matran_n = matrix(c(0.05,0.01,0.01,0.02),2,2)#matrice variance covariance normale
matran_e = matrix(c(0.0005,0.0001,0.0001,0.0002),2,2)#matrice variance covariance extreme
moyran_Ie = c(-4*sqrt(0.05),0)#vecteur moyennes des random intercept
moyran_Pe = c(0,-4*sqrt(0.02))#vecteur moyennes des random pente

#BDD
pourcentN=min(norpRANI,norpRANP) #pourcentage d'individu non contamines






set.seed(rseed)
reg<-mvrnorm(n=round(norp*n_obs),mu=0,Sigma=varRES_n)
indexRES<-rep(0,length(reg))
res<-data.frame(cbind(reg,indexRES))
colnames(res)<-c("r","indexRES")

if (extp>0){
  set.seed(rseed*10000)
  ext<-mvrnorm(n=round(extp*n_obs),mu=moyRES_e,Sigma=varRES_e)  #residus extremes, normale translate
  indexRES<-rep(1,length(ext))
  ext<-data.frame(cbind(ext,indexRES))
  colnames(ext)<-c("r","indexRES")
  r_inter<-rbind(res,ext)
  
  set.seed(rseed*20000)
  indexRES<-sample(c(1:n_obs),n_obs,replace=F)
  resi<-NULL
  R<-NULL
  for (i in indexRES){
    res<-r_inter[i,] 
    R<-rbind(R,res)
  }
}else{
  R<-cbind(res,id)
  colnames(R)<-c("r","indexRES","id")
}



##### EFFETS ALEATOIRES #####


#AVEC CORRELATION ENTRE INTERCEPT ET PENTE
#normale
set.seed(rseed+10000)
u_n<-as.data.frame(mvrnorm(round(pourcentN*n_suj),mu=c(0,0),Sigma=matran_n))
u_n$indexI<-0
u_n$indexP<-0

if(extRANI+extRANP==0){
  U<-cbind(u_n,unique(id))
  colnames(U)<-c("u0","u1","indexRANI","indexRANP","id") 
}else{
  if(extRANI>0){
    #extremeI
    set.seed(rseed+20000)
    u_Ie<-as.data.frame(mvrnorm(round(extRANI*n_suj),mu=moyran_Ie,Sigma=matran_e))
    u_Ie$indexI<-1
    u_Ie$indexP<-0
    u_inter<-data.frame(rbind(u_n,u_Ie))
    
    set.seed(rseed+30000)
    indexRAN<-sample(c(1:n_suj),n_suj,replace=F)
    UU<-NULL
    U<-NULL
    for (i in indexRAN){
      UU<-u_inter[i,] 
      U<-rbind(UU,U)
    }
    U<-cbind(U,unique(id))
    colnames(U)<-c("u0","u1","indexRANI","indexRANP","id") 
  }else{
    #extremeP
    set.seed(rseed+20000)
    u_Pe<-as.data.frame(mvrnorm(round(extRANP*n_suj),mu=moyran_Pe,Sigma=matran_e))
    u_Pe$indexI<-0
    u_Pe$indexP<-1
    u_inter<-data.frame(rbind(u_n,u_Pe))
    
    set.seed(rseed+30000)
    indexRAN<-sample(c(1:n_suj),n_suj,replace=F)
    UU<-NULL
    U<-NULL
    for (i in indexRAN){
      UU<-u_inter[i,] 
      U<-rbind(UU,U)
    }
    U<-cbind(U,unique(id))
    colnames(U)<-c("u0","u1","indexRANI","indexRANP","id")
  }
}

bdd<-cbind(id,temps)
bdd<-merge(bdd,U)
bdd<-cbind(bdd,R)
bdd1<-bdd[,-9]
bdd1$group <- 1
row.names(bdd1)<-c(1:(n_mes*n_suj))





#BDD FINALE
bdd <- rbind(bdd0,bdd1)



bdd$y= (b0 + bG * bdd$group + bT * bdd$temps + bGxT * bdd$group * bdd$temps + bdd$u0 + bdd$u1 * bdd$temps + bdd$r)
bdd$obs<-c(1:dim(bdd)[1])


y = bdd$y #VD
temps = bdd$temps # pente
id = bdd$id # grouping variable
Testeffetfix =F         #autre effet fixe T si oui sinon F
if (Testeffetfix==T){
  effetfixe<-bdd[,c(2,4)]        #selectionner les variables pour les effets fixes
  bddMC = as.data.frame(cbind(y,id,temps,effetfixe))
} else{
  bddMC = as.data.frame(cbind(y,id,temps)) #base de donnÃ©e
} 











# Identify dataset, time and participant variables
Dataset = bdd
time = bdd$temps
participant = bdd$id

###############
# LMM estimations

# 4a) Estimation with varComprob() (see corresponding helpfile for more details)

# Build the argument "groups" of the varComprob() function
n = length(unique(participant)) # the number of participants
J = length(unique(time)) # the number of repeated observations per participant
groups = cbind(rep(1:J, each=n),rep((1:n), J)) # a numeric matrix with two columns used to group the observations according to participant.

# Build the argument "varcov" of the varComprob() function
z1 = rep(1, J) #Value for intercept (=1) for the J observations by clusters
z2 = unique(time) # Value for the time variable

K = list() # the "varcov" object
K[[1]] = tcrossprod(z1,z1) # Matrix for intercept
K[[2]] = tcrossprod(z2,z2) # Matrix for time variable
K[[3]] = tcrossprod(z1,z2) + tcrossprod(z2,z1) # Matrix of interaction Intercept by time variable
names(K) = c("sigma2_Intercept", "sigma2_Time", "Covariance")

# Define the formula of the two nested models
model.formula = y ~ 1 + group*temps
model.formula0 = y ~ 1 + group+temps 

# Estimation with S-estimator
model.S  = varComprob(model.formula, groups = groups, data = Dataset, varcov = K, control = varComprob.control(lower = c(0,0,-Inf), method = "S", psi = "rocke")) 
model.S0 = varComprob(model.formula0, groups = groups, data = Dataset, varcov = K, control = varComprob.control(lower = c(0,0,-Inf), method = "S", psi = "rocke")) 
resS<-summary(model.S)
fixedEffects_S <- model.S$fixef
randomEffects_S <- model.S$eta
sigma2_S <- model.S$eta0

inf = model.S$eta - sqrt(diag(model.S$vcov.eta))*qnorm(.95+0.05/2)
sup = model.S$eta + sqrt(diag(model.S$vcov.eta))*qnorm(.95+0.05/2)

ranTestWaldns_S = inf < 0 & 0 < sup 
pWald_S <- c(resS$zTable[,4])
TestWald_S <- pWald_S>.05
TestWald_S <- c(TestWald_S,NA,ranTestWaldns_S)

wildS <- TestFixef(model = model.S, model0 = model.S0, Data = Dataset, id = participant, Time = time, method = "wild", B = 999, level = .95)
#Testwildns_S = wildS[,1] < 0 & 0 < wildS[,2]

paramS <- TestFixef(model = model.S, model0 = model.S0, Data = Dataset, id = participant, Time = time, method = "parametric", B = 3, level = .95)
#Testparamns_S = paramS[,1] < 0 & 0 < paramS[,2]

# Estimation with composite-TAU estimator
model.cTAU  = varComprob(model.formula, groups = groups, data = Dataset, varcov = K, control = varComprob.control(lower = c(0, 0, -Inf))) 
model.cTAU0 = varComprob(model.formula0, groups = groups, data = Dataset, varcov = K, control = varComprob.control(lower = c(0, 0, -Inf))) 

rescTAU<-summary(model.cTAU)
fixedEffects_cTAU <- model.cTAU$fixef
randomEffects_cTAU <- model.cTAU$eta
sigma2_cTAU <- model.cTAU$eta0

inf = model.cTAU$eta - sqrt(diag(model.cTAU$vcov.eta))*qnorm(.95+0.05/2)
sup = model.cTAU$eta + sqrt(diag(model.cTAU$vcov.eta))*qnorm(.95+0.05/2)

ranTestWaldns_cTAU = inf < 0 & 0 < sup 
pWald_cTAU <- c(rescTAU$zTable[,4])
TestWald_cTAU <- pWald_cTAU>.05
TestWald_cTAU <- c(TestWald_cTAU,NA,ranTestWaldns_cTAU)

wildcTAU <- TestFixef(model = model.cTAU, model0 = model.cTAU0, Data = Dataset, id = participant, Time = time, method = "wild", B = 999, level = .95)
#Testwildns_cTAU = wildcTAU[,1] < 0 & 0 < wildcTAU[,2]

paramcTAU <- TestFixef(model = model.cTAU, model0 = model.cTAU0, Data = Dataset, id = participant, Time = time, method = "parametric", B = 9, level = .95)
#Testparamns_cTAU = paramcTAU[,1] < 0 & 0 < paramcTAU[,2]

# 4b) Estimation with rlmer() (see corresponding helpfile for more details)

# Estimation with SMDM
model.SMDM = rlmer(y ~ 1 + group*temps + (temps|id), data = Dataset, rho.sigma.e = psi2propII(smoothPsi, k = 2.28), rho.sigma.b = chgDefaults(smoothPsi, k = 5.11, s = 10))                   
model.SMDM0 = rlmer(y ~ 1 + group + temps + (temps|id), data = Dataset, rho.sigma.e = psi2propII(smoothPsi, k = 2.28), rho.sigma.b = chgDefaults(smoothPsi, k = 5.11, s = 10))                   
summ=summary(model.SMDM)
fixedEffects_SMDM <- fixef(model.SMDM)
randomEffects_SMDM <- c(VarCorr(model.SMDM)$id[1,1], VarCorr(model.SMDM)$id[2,2],VarCorr(model.SMDM)$id[2,1])
sigma2_SMDM <- sigma(model.SMDM)^2


inf = c(fixef(model.SMDM) - summ$coefficients[,2]*qnorm(.95+.05/2))
sup = c(fixef(model.SMDM) + summ$coefficients[,2]*qnorm(.95+.05/2))
TestWaldns_SMDM = inf < 0 & 0 < sup
TestWaldns_SMDM = c(TestWaldns_SMDM,NA,NA,NA,NA)

wildSMDM <- TestFixef(model = model.SMDM, model0 = model.SMDM0, Data = Dataset, id = participant, Time = time, method = "wild", B = 99, level = .95)
#Testwildns_SMDM = wildSMDM[,1] < 0 & 0 < wildSMDM[,2]

paramSMDM <- TestFixef(model = model.SMDM, model0 = model.SMDM0, Data = Dataset, id = participant, Time = time, method = "parametric", B = 99, level = .95)
#Testparamns_SMDM = paramSMDM[,1] < 0 & 0 < paramSMDM[,2]


# 4c) Estimation with heavyLme() (see corresponding helpfile for more details)

# Estimation with the multivarite t-ML
model.tML = heavyLme(y ~ 1 + group*temps, random = ~ 1 + temps, groups = ~ id, data = Dataset) 
model.tML0 = heavyLme(y ~ 1 + group + temps, random = ~ 1 + temps, groups = ~ id, data = Dataset) 

summ = summary(model.tML)
fixedEffects_tML 			= model.tML$coefficients
randomEffects_tML 	= c(summ$theta[1,1]*(model.tML$settings[3])/(model.tML$settings[3]-2),
                       summ$theta[2,2]*(model.tML$settings[3])/(model.tML$settings[3]-2),
                       summ$theta[1,2]*(model.tML$settings[3])/(model.tML$settings[3]-2))
sigma2_tML 		= summ$scale*(model.tML$settings[3])/(model.tML$settings[3]-2)

inf = c(coefficients(model.tML) - summ$coefficients[,2]*qnorm(.975))
sup = c(coefficients(model.tML) + summ$coefficients[,2]*qnorm(.975))
TestWaldns_tML = inf < 0 & 0 < sup
TestWaldns_tML = c(TestWaldns_tML,NA,NA,NA,NA)

wildtML <- TestFixef(model = model.tML, model0 = model.tML0, Data = Dataset, id = participant, Time = time, method = "wild", B = 999, level = .95)
#Testwildns_tML = wildtML[,1] < 0 & 0 < wildtML[,2]

paramtML <- TestFixef(model = model.tML, model0 = model.tML0, Data = Dataset, id = participant, Time = time, method = "parametric", B = 99, level = .95)
#Testparamns_tML = paramtML[,1] < 0 & 0 < paramtML[,2]

# 4d) Estimation with lmer() (see corresponding helpfile for more details)

# Estimation with ML
model.ML = lmer(y ~ 1 + group*temps + (temps|id), data = Dataset, REML = F)
model.ML0 = lmer(y ~ 1 + group + temps + (temps|id), data = Dataset, REML = F)

summ=summary(model.ML)
fixedEffects_ML <- fixef(model.ML)
randomEffects_ML <- c(VarCorr(model.ML)$id[1,1], VarCorr(model.ML)$id[2,2],VarCorr(model.ML)$id[2,1])
sigma2_ML <- sigma(model.ML)^2


inf = c(fixef(model.ML) - summ$coefficients[,2]*qnorm(.95+.05/2))
sup = c(fixef(model.ML) + summ$coefficients[,2]*qnorm(.95+.05/2))
TestWaldns_ML = inf < 0 & 0 < sup
TestWaldns_ML = c(TestWaldns_ML,NA,NA,NA,NA)

pSatterth_ML <- c(summ$coefficients[,5])

Profile <- confint(model.ML)
TestProfilens_ML = Profile[,1] < 0 & 0 < Profile[,2]
TestProfilens_ML = TestProfilens_ML[c(5,6,7,8,4,1,3,2)]


model.MLgroup = lmer(y ~ 1 + temps+group:temps + (temps|id), data = Dataset, REML = F)
model.MLtime = lmer(y ~ 1 + group+group:temps + (temps|id), data = Dataset, REML = F)
model.MLinter = lmer(y ~ 1 + group+temps + (temps|id), data = Dataset, REML = F)
model.MLI = lmer(y ~ 0 + group*temps + (temps|id), data = Dataset, REML = F)
model.MLranS = lmer(y ~ 1 + group*temps + (1|id), data = Dataset, REML = F)
model.MLcov = lmer(y ~ 1 + group*temps + (temps||id), data = Dataset, REML = F)

ranova(model.MLranS)
LRT_intercept<-anova(model.ML,model.MLI)
LRT_group<-anova(model.ML,model.MLgroup)
LRT_time<-anova(model.ML,model.MLtime)
LRT_interaction<-anova(model.ML,model.MLinter)
LRT_ranI<-ranova(model.MLranS)
LRT_ranS<-anova(model.MLranS,model.MLcov)
LRT_covariance<-anova(model.ML,model.MLcov)

pLRT <- c(LRT_intercept[2,8],LRT_group[2,8],LRT_time[2,8],LRT_interaction[2,8],NA,LRT_ranI[2,6],LRT_ranS[2,8],LRT_covariance[2,8])

wildML <- TestFixef(model = model.ML, model0 = model.ML0, Data = Dataset, id = participant, Time = time, method = "wild", B = 99, level = .95)
#Testwildns_ML = wildML[,1] < 0 & 0 < wildML[,2]

paramML <- TestFixef(model = model.ML, model0 = model.ML0, Data = Dataset, id = participant, Time = time, method = "parametric", B = 999, level = .95)
#Testparamns_ML = paramcML[,1] < 0 & 0 < paramcML[,2]
